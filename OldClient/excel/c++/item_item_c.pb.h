// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: item_item_c.proto

#ifndef PROTOBUF_item_5fitem_5fc_2eproto__INCLUDED
#define PROTOBUF_item_5fitem_5fc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_item_5fitem_5fc_2eproto();
void protobuf_AssignDesc_item_5fitem_5fc_2eproto();
void protobuf_ShutdownFile_item_5fitem_5fc_2eproto();

class item_item;
class item_item_c;

// ===================================================================

class item_item : public ::google::protobuf::Message {
 public:
  item_item();
  virtual ~item_item();
  
  item_item(const item_item& from);
  
  inline item_item& operator=(const item_item& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const item_item& default_instance();
  
  void Swap(item_item* other);
  
  // implements Message ----------------------------------------------
  
  item_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const item_item& from);
  void MergeFrom(const item_item& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 item_id = 1;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);
  
  // optional bool unk_1 = 2;
  inline bool has_unk_1() const;
  inline void clear_unk_1();
  static const int kUnk1FieldNumber = 2;
  inline bool unk_1() const;
  inline void set_unk_1(bool value);
  
  // optional bool unk_2 = 3;
  inline bool has_unk_2() const;
  inline void clear_unk_2();
  static const int kUnk2FieldNumber = 3;
  inline bool unk_2() const;
  inline void set_unk_2(bool value);
  
  // optional bool unk_3 = 4;
  inline bool has_unk_3() const;
  inline void clear_unk_3();
  static const int kUnk3FieldNumber = 4;
  inline bool unk_3() const;
  inline void set_unk_3(bool value);
  
  // optional bool unk_4 = 5;
  inline bool has_unk_4() const;
  inline void clear_unk_4();
  static const int kUnk4FieldNumber = 5;
  inline bool unk_4() const;
  inline void set_unk_4(bool value);
  
  // optional bool unk_5 = 6;
  inline bool has_unk_5() const;
  inline void clear_unk_5();
  static const int kUnk5FieldNumber = 6;
  inline bool unk_5() const;
  inline void set_unk_5(bool value);
  
  // optional bool unk_6 = 7;
  inline bool has_unk_6() const;
  inline void clear_unk_6();
  static const int kUnk6FieldNumber = 7;
  inline bool unk_6() const;
  inline void set_unk_6(bool value);
  
  // optional bool unk_6x = 8;
  inline bool has_unk_6x() const;
  inline void clear_unk_6x();
  static const int kUnk6XFieldNumber = 8;
  inline bool unk_6x() const;
  inline void set_unk_6x(bool value);
  
  // optional bool unk_i_6 = 9;
  inline bool has_unk_i_6() const;
  inline void clear_unk_i_6();
  static const int kUnkI6FieldNumber = 9;
  inline bool unk_i_6() const;
  inline void set_unk_i_6(bool value);
  
  // required string item_type = 10;
  inline bool has_item_type() const;
  inline void clear_item_type();
  static const int kItemTypeFieldNumber = 10;
  inline const ::std::string& item_type() const;
  inline void set_item_type(const ::std::string& value);
  inline void set_item_type(const char* value);
  inline void set_item_type(const char* value, size_t size);
  inline ::std::string* mutable_item_type();
  inline ::std::string* release_item_type();
  
  // optional bool unk_11 = 11;
  inline bool has_unk_11() const;
  inline void clear_unk_11();
  static const int kUnk11FieldNumber = 11;
  inline bool unk_11() const;
  inline void set_unk_11(bool value);
  
  // optional bool unk_12 = 12;
  inline bool has_unk_12() const;
  inline void clear_unk_12();
  static const int kUnk12FieldNumber = 12;
  inline bool unk_12() const;
  inline void set_unk_12(bool value);
  
  // optional bool unk_13 = 13;
  inline bool has_unk_13() const;
  inline void clear_unk_13();
  static const int kUnk13FieldNumber = 13;
  inline bool unk_13() const;
  inline void set_unk_13(bool value);
  
  // optional bool unk_14 = 14;
  inline bool has_unk_14() const;
  inline void clear_unk_14();
  static const int kUnk14FieldNumber = 14;
  inline bool unk_14() const;
  inline void set_unk_14(bool value);
  
  // optional bool unk_15 = 15;
  inline bool has_unk_15() const;
  inline void clear_unk_15();
  static const int kUnk15FieldNumber = 15;
  inline bool unk_15() const;
  inline void set_unk_15(bool value);
  
  // optional bool unk_16 = 16;
  inline bool has_unk_16() const;
  inline void clear_unk_16();
  static const int kUnk16FieldNumber = 16;
  inline bool unk_16() const;
  inline void set_unk_16(bool value);
  
  // optional bool unk_17 = 17;
  inline bool has_unk_17() const;
  inline void clear_unk_17();
  static const int kUnk17FieldNumber = 17;
  inline bool unk_17() const;
  inline void set_unk_17(bool value);
  
  // optional bool unk_18 = 18;
  inline bool has_unk_18() const;
  inline void clear_unk_18();
  static const int kUnk18FieldNumber = 18;
  inline bool unk_18() const;
  inline void set_unk_18(bool value);
  
  // optional bool unk_19 = 19;
  inline bool has_unk_19() const;
  inline void clear_unk_19();
  static const int kUnk19FieldNumber = 19;
  inline bool unk_19() const;
  inline void set_unk_19(bool value);
  
  // optional bool unk_20 = 20;
  inline bool has_unk_20() const;
  inline void clear_unk_20();
  static const int kUnk20FieldNumber = 20;
  inline bool unk_20() const;
  inline void set_unk_20(bool value);
  
  // optional bool unk_21 = 21;
  inline bool has_unk_21() const;
  inline void clear_unk_21();
  static const int kUnk21FieldNumber = 21;
  inline bool unk_21() const;
  inline void set_unk_21(bool value);
  
  // optional bool unk_22 = 22;
  inline bool has_unk_22() const;
  inline void clear_unk_22();
  static const int kUnk22FieldNumber = 22;
  inline bool unk_22() const;
  inline void set_unk_22(bool value);
  
  // optional bytes name = 23;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 23;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional bytes desc = 24;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 24;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const void* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  
  // optional bool unk_25 = 25;
  inline bool has_unk_25() const;
  inline void clear_unk_25();
  static const int kUnk25FieldNumber = 25;
  inline bool unk_25() const;
  inline void set_unk_25(bool value);
  
  // optional string ico = 26;
  inline bool has_ico() const;
  inline void clear_ico();
  static const int kIcoFieldNumber = 26;
  inline const ::std::string& ico() const;
  inline void set_ico(const ::std::string& value);
  inline void set_ico(const char* value);
  inline void set_ico(const char* value, size_t size);
  inline ::std::string* mutable_ico();
  inline ::std::string* release_ico();
  
  // optional int32 unk_id = 28;
  inline bool has_unk_id() const;
  inline void clear_unk_id();
  static const int kUnkIdFieldNumber = 28;
  inline ::google::protobuf::int32 unk_id() const;
  inline void set_unk_id(::google::protobuf::int32 value);
  
  // optional bytes shop_type = 29;
  inline bool has_shop_type() const;
  inline void clear_shop_type();
  static const int kShopTypeFieldNumber = 29;
  inline const ::std::string& shop_type() const;
  inline void set_shop_type(const ::std::string& value);
  inline void set_shop_type(const char* value);
  inline void set_shop_type(const void* value, size_t size);
  inline ::std::string* mutable_shop_type();
  inline ::std::string* release_shop_type();
  
  // optional int32 unk_30 = 30;
  inline bool has_unk_30() const;
  inline void clear_unk_30();
  static const int kUnk30FieldNumber = 30;
  inline ::google::protobuf::int32 unk_30() const;
  inline void set_unk_30(::google::protobuf::int32 value);
  
  // optional int32 unk_31 = 31;
  inline bool has_unk_31() const;
  inline void clear_unk_31();
  static const int kUnk31FieldNumber = 31;
  inline ::google::protobuf::int32 unk_31() const;
  inline void set_unk_31(::google::protobuf::int32 value);
  
  // optional int32 unk_32 = 32;
  inline bool has_unk_32() const;
  inline void clear_unk_32();
  static const int kUnk32FieldNumber = 32;
  inline ::google::protobuf::int32 unk_32() const;
  inline void set_unk_32(::google::protobuf::int32 value);
  
  // optional int32 unk_33 = 33;
  inline bool has_unk_33() const;
  inline void clear_unk_33();
  static const int kUnk33FieldNumber = 33;
  inline ::google::protobuf::int32 unk_33() const;
  inline void set_unk_33(::google::protobuf::int32 value);
  
  // optional int32 unk_34 = 34;
  inline bool has_unk_34() const;
  inline void clear_unk_34();
  static const int kUnk34FieldNumber = 34;
  inline ::google::protobuf::int32 unk_34() const;
  inline void set_unk_34(::google::protobuf::int32 value);
  
  // optional int32 unk_35 = 35;
  inline bool has_unk_35() const;
  inline void clear_unk_35();
  static const int kUnk35FieldNumber = 35;
  inline ::google::protobuf::int32 unk_35() const;
  inline void set_unk_35(::google::protobuf::int32 value);
  
  // optional int32 unk_36 = 36;
  inline bool has_unk_36() const;
  inline void clear_unk_36();
  static const int kUnk36FieldNumber = 36;
  inline ::google::protobuf::int32 unk_36() const;
  inline void set_unk_36(::google::protobuf::int32 value);
  
  // optional int32 unk_37 = 37;
  inline bool has_unk_37() const;
  inline void clear_unk_37();
  static const int kUnk37FieldNumber = 37;
  inline ::google::protobuf::int32 unk_37() const;
  inline void set_unk_37(::google::protobuf::int32 value);
  
  // optional string scene = 38;
  inline bool has_scene() const;
  inline void clear_scene();
  static const int kSceneFieldNumber = 38;
  inline const ::std::string& scene() const;
  inline void set_scene(const ::std::string& value);
  inline void set_scene(const char* value);
  inline void set_scene(const char* value, size_t size);
  inline ::std::string* mutable_scene();
  inline ::std::string* release_scene();
  
  // optional int32 unk_39 = 39;
  inline bool has_unk_39() const;
  inline void clear_unk_39();
  static const int kUnk39FieldNumber = 39;
  inline ::google::protobuf::int32 unk_39() const;
  inline void set_unk_39(::google::protobuf::int32 value);
  
  // optional string unk_40 = 40;
  inline bool has_unk_40() const;
  inline void clear_unk_40();
  static const int kUnk40FieldNumber = 40;
  inline const ::std::string& unk_40() const;
  inline void set_unk_40(const ::std::string& value);
  inline void set_unk_40(const char* value);
  inline void set_unk_40(const char* value, size_t size);
  inline ::std::string* mutable_unk_40();
  inline ::std::string* release_unk_40();
  
  // optional int32 unk_41 = 41;
  inline bool has_unk_41() const;
  inline void clear_unk_41();
  static const int kUnk41FieldNumber = 41;
  inline ::google::protobuf::int32 unk_41() const;
  inline void set_unk_41(::google::protobuf::int32 value);
  
  // optional string ff = 42;
  inline bool has_ff() const;
  inline void clear_ff();
  static const int kFfFieldNumber = 42;
  inline const ::std::string& ff() const;
  inline void set_ff(const ::std::string& value);
  inline void set_ff(const char* value);
  inline void set_ff(const char* value, size_t size);
  inline ::std::string* mutable_ff();
  inline ::std::string* release_ff();
  
  // optional int32 unk_43 = 43;
  inline bool has_unk_43() const;
  inline void clear_unk_43();
  static const int kUnk43FieldNumber = 43;
  inline ::google::protobuf::int32 unk_43() const;
  inline void set_unk_43(::google::protobuf::int32 value);
  
  // optional int32 unk_44 = 44;
  inline bool has_unk_44() const;
  inline void clear_unk_44();
  static const int kUnk44FieldNumber = 44;
  inline ::google::protobuf::int32 unk_44() const;
  inline void set_unk_44(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:item_item)
 private:
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_unk_1();
  inline void clear_has_unk_1();
  inline void set_has_unk_2();
  inline void clear_has_unk_2();
  inline void set_has_unk_3();
  inline void clear_has_unk_3();
  inline void set_has_unk_4();
  inline void clear_has_unk_4();
  inline void set_has_unk_5();
  inline void clear_has_unk_5();
  inline void set_has_unk_6();
  inline void clear_has_unk_6();
  inline void set_has_unk_6x();
  inline void clear_has_unk_6x();
  inline void set_has_unk_i_6();
  inline void clear_has_unk_i_6();
  inline void set_has_item_type();
  inline void clear_has_item_type();
  inline void set_has_unk_11();
  inline void clear_has_unk_11();
  inline void set_has_unk_12();
  inline void clear_has_unk_12();
  inline void set_has_unk_13();
  inline void clear_has_unk_13();
  inline void set_has_unk_14();
  inline void clear_has_unk_14();
  inline void set_has_unk_15();
  inline void clear_has_unk_15();
  inline void set_has_unk_16();
  inline void clear_has_unk_16();
  inline void set_has_unk_17();
  inline void clear_has_unk_17();
  inline void set_has_unk_18();
  inline void clear_has_unk_18();
  inline void set_has_unk_19();
  inline void clear_has_unk_19();
  inline void set_has_unk_20();
  inline void clear_has_unk_20();
  inline void set_has_unk_21();
  inline void clear_has_unk_21();
  inline void set_has_unk_22();
  inline void clear_has_unk_22();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_unk_25();
  inline void clear_has_unk_25();
  inline void set_has_ico();
  inline void clear_has_ico();
  inline void set_has_unk_id();
  inline void clear_has_unk_id();
  inline void set_has_shop_type();
  inline void clear_has_shop_type();
  inline void set_has_unk_30();
  inline void clear_has_unk_30();
  inline void set_has_unk_31();
  inline void clear_has_unk_31();
  inline void set_has_unk_32();
  inline void clear_has_unk_32();
  inline void set_has_unk_33();
  inline void clear_has_unk_33();
  inline void set_has_unk_34();
  inline void clear_has_unk_34();
  inline void set_has_unk_35();
  inline void clear_has_unk_35();
  inline void set_has_unk_36();
  inline void clear_has_unk_36();
  inline void set_has_unk_37();
  inline void clear_has_unk_37();
  inline void set_has_scene();
  inline void clear_has_scene();
  inline void set_has_unk_39();
  inline void clear_has_unk_39();
  inline void set_has_unk_40();
  inline void clear_has_unk_40();
  inline void set_has_unk_41();
  inline void clear_has_unk_41();
  inline void set_has_ff();
  inline void clear_has_ff();
  inline void set_has_unk_43();
  inline void clear_has_unk_43();
  inline void set_has_unk_44();
  inline void clear_has_unk_44();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 item_id_;
  bool unk_1_;
  bool unk_2_;
  bool unk_3_;
  bool unk_4_;
  ::std::string* item_type_;
  bool unk_5_;
  bool unk_6_;
  bool unk_6x_;
  bool unk_i_6_;
  bool unk_11_;
  bool unk_12_;
  bool unk_13_;
  bool unk_14_;
  bool unk_15_;
  bool unk_16_;
  bool unk_17_;
  bool unk_18_;
  bool unk_19_;
  bool unk_20_;
  bool unk_21_;
  bool unk_22_;
  ::std::string* name_;
  ::std::string* desc_;
  ::std::string* ico_;
  bool unk_25_;
  ::google::protobuf::int32 unk_id_;
  ::std::string* shop_type_;
  ::google::protobuf::int32 unk_30_;
  ::google::protobuf::int32 unk_31_;
  ::google::protobuf::int32 unk_32_;
  ::google::protobuf::int32 unk_33_;
  ::google::protobuf::int32 unk_34_;
  ::google::protobuf::int32 unk_35_;
  ::google::protobuf::int32 unk_36_;
  ::google::protobuf::int32 unk_37_;
  ::std::string* scene_;
  ::std::string* unk_40_;
  ::google::protobuf::int32 unk_39_;
  ::google::protobuf::int32 unk_41_;
  ::std::string* ff_;
  ::google::protobuf::int32 unk_43_;
  ::google::protobuf::int32 unk_44_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(43 + 31) / 32];
  
  friend void  protobuf_AddDesc_item_5fitem_5fc_2eproto();
  friend void protobuf_AssignDesc_item_5fitem_5fc_2eproto();
  friend void protobuf_ShutdownFile_item_5fitem_5fc_2eproto();
  
  void InitAsDefaultInstance();
  static item_item* default_instance_;
};
// -------------------------------------------------------------------

class item_item_c : public ::google::protobuf::Message {
 public:
  item_item_c();
  virtual ~item_item_c();
  
  item_item_c(const item_item_c& from);
  
  inline item_item_c& operator=(const item_item_c& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const item_item_c& default_instance();
  
  void Swap(item_item_c* other);
  
  // implements Message ----------------------------------------------
  
  item_item_c* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const item_item_c& from);
  void MergeFrom(const item_item_c& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .item_item items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::item_item& items(int index) const;
  inline ::item_item* mutable_items(int index);
  inline ::item_item* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::item_item >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::item_item >*
      mutable_items();
  
  // @@protoc_insertion_point(class_scope:item_item_c)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::item_item > items_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_item_5fitem_5fc_2eproto();
  friend void protobuf_AssignDesc_item_5fitem_5fc_2eproto();
  friend void protobuf_ShutdownFile_item_5fitem_5fc_2eproto();
  
  void InitAsDefaultInstance();
  static item_item_c* default_instance_;
};
// ===================================================================


// ===================================================================

// item_item

// required int32 item_id = 1;
inline bool item_item::has_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void item_item::set_has_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void item_item::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void item_item::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 item_item::item_id() const {
  return item_id_;
}
inline void item_item::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// optional bool unk_1 = 2;
inline bool item_item::has_unk_1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void item_item::set_has_unk_1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void item_item::clear_has_unk_1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void item_item::clear_unk_1() {
  unk_1_ = false;
  clear_has_unk_1();
}
inline bool item_item::unk_1() const {
  return unk_1_;
}
inline void item_item::set_unk_1(bool value) {
  set_has_unk_1();
  unk_1_ = value;
}

// optional bool unk_2 = 3;
inline bool item_item::has_unk_2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void item_item::set_has_unk_2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void item_item::clear_has_unk_2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void item_item::clear_unk_2() {
  unk_2_ = false;
  clear_has_unk_2();
}
inline bool item_item::unk_2() const {
  return unk_2_;
}
inline void item_item::set_unk_2(bool value) {
  set_has_unk_2();
  unk_2_ = value;
}

// optional bool unk_3 = 4;
inline bool item_item::has_unk_3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void item_item::set_has_unk_3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void item_item::clear_has_unk_3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void item_item::clear_unk_3() {
  unk_3_ = false;
  clear_has_unk_3();
}
inline bool item_item::unk_3() const {
  return unk_3_;
}
inline void item_item::set_unk_3(bool value) {
  set_has_unk_3();
  unk_3_ = value;
}

// optional bool unk_4 = 5;
inline bool item_item::has_unk_4() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void item_item::set_has_unk_4() {
  _has_bits_[0] |= 0x00000010u;
}
inline void item_item::clear_has_unk_4() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void item_item::clear_unk_4() {
  unk_4_ = false;
  clear_has_unk_4();
}
inline bool item_item::unk_4() const {
  return unk_4_;
}
inline void item_item::set_unk_4(bool value) {
  set_has_unk_4();
  unk_4_ = value;
}

// optional bool unk_5 = 6;
inline bool item_item::has_unk_5() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void item_item::set_has_unk_5() {
  _has_bits_[0] |= 0x00000020u;
}
inline void item_item::clear_has_unk_5() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void item_item::clear_unk_5() {
  unk_5_ = false;
  clear_has_unk_5();
}
inline bool item_item::unk_5() const {
  return unk_5_;
}
inline void item_item::set_unk_5(bool value) {
  set_has_unk_5();
  unk_5_ = value;
}

// optional bool unk_6 = 7;
inline bool item_item::has_unk_6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void item_item::set_has_unk_6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void item_item::clear_has_unk_6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void item_item::clear_unk_6() {
  unk_6_ = false;
  clear_has_unk_6();
}
inline bool item_item::unk_6() const {
  return unk_6_;
}
inline void item_item::set_unk_6(bool value) {
  set_has_unk_6();
  unk_6_ = value;
}

// optional bool unk_6x = 8;
inline bool item_item::has_unk_6x() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void item_item::set_has_unk_6x() {
  _has_bits_[0] |= 0x00000080u;
}
inline void item_item::clear_has_unk_6x() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void item_item::clear_unk_6x() {
  unk_6x_ = false;
  clear_has_unk_6x();
}
inline bool item_item::unk_6x() const {
  return unk_6x_;
}
inline void item_item::set_unk_6x(bool value) {
  set_has_unk_6x();
  unk_6x_ = value;
}

// optional bool unk_i_6 = 9;
inline bool item_item::has_unk_i_6() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void item_item::set_has_unk_i_6() {
  _has_bits_[0] |= 0x00000100u;
}
inline void item_item::clear_has_unk_i_6() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void item_item::clear_unk_i_6() {
  unk_i_6_ = false;
  clear_has_unk_i_6();
}
inline bool item_item::unk_i_6() const {
  return unk_i_6_;
}
inline void item_item::set_unk_i_6(bool value) {
  set_has_unk_i_6();
  unk_i_6_ = value;
}

// required string item_type = 10;
inline bool item_item::has_item_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void item_item::set_has_item_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void item_item::clear_has_item_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void item_item::clear_item_type() {
  if (item_type_ != &::google::protobuf::internal::kEmptyString) {
    item_type_->clear();
  }
  clear_has_item_type();
}
inline const ::std::string& item_item::item_type() const {
  return *item_type_;
}
inline void item_item::set_item_type(const ::std::string& value) {
  set_has_item_type();
  if (item_type_ == &::google::protobuf::internal::kEmptyString) {
    item_type_ = new ::std::string;
  }
  item_type_->assign(value);
}
inline void item_item::set_item_type(const char* value) {
  set_has_item_type();
  if (item_type_ == &::google::protobuf::internal::kEmptyString) {
    item_type_ = new ::std::string;
  }
  item_type_->assign(value);
}
inline void item_item::set_item_type(const char* value, size_t size) {
  set_has_item_type();
  if (item_type_ == &::google::protobuf::internal::kEmptyString) {
    item_type_ = new ::std::string;
  }
  item_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* item_item::mutable_item_type() {
  set_has_item_type();
  if (item_type_ == &::google::protobuf::internal::kEmptyString) {
    item_type_ = new ::std::string;
  }
  return item_type_;
}
inline ::std::string* item_item::release_item_type() {
  clear_has_item_type();
  if (item_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = item_type_;
    item_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool unk_11 = 11;
inline bool item_item::has_unk_11() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void item_item::set_has_unk_11() {
  _has_bits_[0] |= 0x00000400u;
}
inline void item_item::clear_has_unk_11() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void item_item::clear_unk_11() {
  unk_11_ = false;
  clear_has_unk_11();
}
inline bool item_item::unk_11() const {
  return unk_11_;
}
inline void item_item::set_unk_11(bool value) {
  set_has_unk_11();
  unk_11_ = value;
}

// optional bool unk_12 = 12;
inline bool item_item::has_unk_12() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void item_item::set_has_unk_12() {
  _has_bits_[0] |= 0x00000800u;
}
inline void item_item::clear_has_unk_12() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void item_item::clear_unk_12() {
  unk_12_ = false;
  clear_has_unk_12();
}
inline bool item_item::unk_12() const {
  return unk_12_;
}
inline void item_item::set_unk_12(bool value) {
  set_has_unk_12();
  unk_12_ = value;
}

// optional bool unk_13 = 13;
inline bool item_item::has_unk_13() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void item_item::set_has_unk_13() {
  _has_bits_[0] |= 0x00001000u;
}
inline void item_item::clear_has_unk_13() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void item_item::clear_unk_13() {
  unk_13_ = false;
  clear_has_unk_13();
}
inline bool item_item::unk_13() const {
  return unk_13_;
}
inline void item_item::set_unk_13(bool value) {
  set_has_unk_13();
  unk_13_ = value;
}

// optional bool unk_14 = 14;
inline bool item_item::has_unk_14() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void item_item::set_has_unk_14() {
  _has_bits_[0] |= 0x00002000u;
}
inline void item_item::clear_has_unk_14() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void item_item::clear_unk_14() {
  unk_14_ = false;
  clear_has_unk_14();
}
inline bool item_item::unk_14() const {
  return unk_14_;
}
inline void item_item::set_unk_14(bool value) {
  set_has_unk_14();
  unk_14_ = value;
}

// optional bool unk_15 = 15;
inline bool item_item::has_unk_15() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void item_item::set_has_unk_15() {
  _has_bits_[0] |= 0x00004000u;
}
inline void item_item::clear_has_unk_15() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void item_item::clear_unk_15() {
  unk_15_ = false;
  clear_has_unk_15();
}
inline bool item_item::unk_15() const {
  return unk_15_;
}
inline void item_item::set_unk_15(bool value) {
  set_has_unk_15();
  unk_15_ = value;
}

// optional bool unk_16 = 16;
inline bool item_item::has_unk_16() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void item_item::set_has_unk_16() {
  _has_bits_[0] |= 0x00008000u;
}
inline void item_item::clear_has_unk_16() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void item_item::clear_unk_16() {
  unk_16_ = false;
  clear_has_unk_16();
}
inline bool item_item::unk_16() const {
  return unk_16_;
}
inline void item_item::set_unk_16(bool value) {
  set_has_unk_16();
  unk_16_ = value;
}

// optional bool unk_17 = 17;
inline bool item_item::has_unk_17() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void item_item::set_has_unk_17() {
  _has_bits_[0] |= 0x00010000u;
}
inline void item_item::clear_has_unk_17() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void item_item::clear_unk_17() {
  unk_17_ = false;
  clear_has_unk_17();
}
inline bool item_item::unk_17() const {
  return unk_17_;
}
inline void item_item::set_unk_17(bool value) {
  set_has_unk_17();
  unk_17_ = value;
}

// optional bool unk_18 = 18;
inline bool item_item::has_unk_18() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void item_item::set_has_unk_18() {
  _has_bits_[0] |= 0x00020000u;
}
inline void item_item::clear_has_unk_18() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void item_item::clear_unk_18() {
  unk_18_ = false;
  clear_has_unk_18();
}
inline bool item_item::unk_18() const {
  return unk_18_;
}
inline void item_item::set_unk_18(bool value) {
  set_has_unk_18();
  unk_18_ = value;
}

// optional bool unk_19 = 19;
inline bool item_item::has_unk_19() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void item_item::set_has_unk_19() {
  _has_bits_[0] |= 0x00040000u;
}
inline void item_item::clear_has_unk_19() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void item_item::clear_unk_19() {
  unk_19_ = false;
  clear_has_unk_19();
}
inline bool item_item::unk_19() const {
  return unk_19_;
}
inline void item_item::set_unk_19(bool value) {
  set_has_unk_19();
  unk_19_ = value;
}

// optional bool unk_20 = 20;
inline bool item_item::has_unk_20() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void item_item::set_has_unk_20() {
  _has_bits_[0] |= 0x00080000u;
}
inline void item_item::clear_has_unk_20() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void item_item::clear_unk_20() {
  unk_20_ = false;
  clear_has_unk_20();
}
inline bool item_item::unk_20() const {
  return unk_20_;
}
inline void item_item::set_unk_20(bool value) {
  set_has_unk_20();
  unk_20_ = value;
}

// optional bool unk_21 = 21;
inline bool item_item::has_unk_21() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void item_item::set_has_unk_21() {
  _has_bits_[0] |= 0x00100000u;
}
inline void item_item::clear_has_unk_21() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void item_item::clear_unk_21() {
  unk_21_ = false;
  clear_has_unk_21();
}
inline bool item_item::unk_21() const {
  return unk_21_;
}
inline void item_item::set_unk_21(bool value) {
  set_has_unk_21();
  unk_21_ = value;
}

// optional bool unk_22 = 22;
inline bool item_item::has_unk_22() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void item_item::set_has_unk_22() {
  _has_bits_[0] |= 0x00200000u;
}
inline void item_item::clear_has_unk_22() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void item_item::clear_unk_22() {
  unk_22_ = false;
  clear_has_unk_22();
}
inline bool item_item::unk_22() const {
  return unk_22_;
}
inline void item_item::set_unk_22(bool value) {
  set_has_unk_22();
  unk_22_ = value;
}

// optional bytes name = 23;
inline bool item_item::has_name() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void item_item::set_has_name() {
  _has_bits_[0] |= 0x00400000u;
}
inline void item_item::clear_has_name() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void item_item::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& item_item::name() const {
  return *name_;
}
inline void item_item::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void item_item::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void item_item::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* item_item::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* item_item::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes desc = 24;
inline bool item_item::has_desc() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void item_item::set_has_desc() {
  _has_bits_[0] |= 0x00800000u;
}
inline void item_item::clear_has_desc() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void item_item::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& item_item::desc() const {
  return *desc_;
}
inline void item_item::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void item_item::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void item_item::set_desc(const void* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* item_item::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* item_item::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool unk_25 = 25;
inline bool item_item::has_unk_25() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void item_item::set_has_unk_25() {
  _has_bits_[0] |= 0x01000000u;
}
inline void item_item::clear_has_unk_25() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void item_item::clear_unk_25() {
  unk_25_ = false;
  clear_has_unk_25();
}
inline bool item_item::unk_25() const {
  return unk_25_;
}
inline void item_item::set_unk_25(bool value) {
  set_has_unk_25();
  unk_25_ = value;
}

// optional string ico = 26;
inline bool item_item::has_ico() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void item_item::set_has_ico() {
  _has_bits_[0] |= 0x02000000u;
}
inline void item_item::clear_has_ico() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void item_item::clear_ico() {
  if (ico_ != &::google::protobuf::internal::kEmptyString) {
    ico_->clear();
  }
  clear_has_ico();
}
inline const ::std::string& item_item::ico() const {
  return *ico_;
}
inline void item_item::set_ico(const ::std::string& value) {
  set_has_ico();
  if (ico_ == &::google::protobuf::internal::kEmptyString) {
    ico_ = new ::std::string;
  }
  ico_->assign(value);
}
inline void item_item::set_ico(const char* value) {
  set_has_ico();
  if (ico_ == &::google::protobuf::internal::kEmptyString) {
    ico_ = new ::std::string;
  }
  ico_->assign(value);
}
inline void item_item::set_ico(const char* value, size_t size) {
  set_has_ico();
  if (ico_ == &::google::protobuf::internal::kEmptyString) {
    ico_ = new ::std::string;
  }
  ico_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* item_item::mutable_ico() {
  set_has_ico();
  if (ico_ == &::google::protobuf::internal::kEmptyString) {
    ico_ = new ::std::string;
  }
  return ico_;
}
inline ::std::string* item_item::release_ico() {
  clear_has_ico();
  if (ico_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ico_;
    ico_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 unk_id = 28;
inline bool item_item::has_unk_id() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void item_item::set_has_unk_id() {
  _has_bits_[0] |= 0x04000000u;
}
inline void item_item::clear_has_unk_id() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void item_item::clear_unk_id() {
  unk_id_ = 0;
  clear_has_unk_id();
}
inline ::google::protobuf::int32 item_item::unk_id() const {
  return unk_id_;
}
inline void item_item::set_unk_id(::google::protobuf::int32 value) {
  set_has_unk_id();
  unk_id_ = value;
}

// optional bytes shop_type = 29;
inline bool item_item::has_shop_type() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void item_item::set_has_shop_type() {
  _has_bits_[0] |= 0x08000000u;
}
inline void item_item::clear_has_shop_type() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void item_item::clear_shop_type() {
  if (shop_type_ != &::google::protobuf::internal::kEmptyString) {
    shop_type_->clear();
  }
  clear_has_shop_type();
}
inline const ::std::string& item_item::shop_type() const {
  return *shop_type_;
}
inline void item_item::set_shop_type(const ::std::string& value) {
  set_has_shop_type();
  if (shop_type_ == &::google::protobuf::internal::kEmptyString) {
    shop_type_ = new ::std::string;
  }
  shop_type_->assign(value);
}
inline void item_item::set_shop_type(const char* value) {
  set_has_shop_type();
  if (shop_type_ == &::google::protobuf::internal::kEmptyString) {
    shop_type_ = new ::std::string;
  }
  shop_type_->assign(value);
}
inline void item_item::set_shop_type(const void* value, size_t size) {
  set_has_shop_type();
  if (shop_type_ == &::google::protobuf::internal::kEmptyString) {
    shop_type_ = new ::std::string;
  }
  shop_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* item_item::mutable_shop_type() {
  set_has_shop_type();
  if (shop_type_ == &::google::protobuf::internal::kEmptyString) {
    shop_type_ = new ::std::string;
  }
  return shop_type_;
}
inline ::std::string* item_item::release_shop_type() {
  clear_has_shop_type();
  if (shop_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shop_type_;
    shop_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 unk_30 = 30;
inline bool item_item::has_unk_30() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void item_item::set_has_unk_30() {
  _has_bits_[0] |= 0x10000000u;
}
inline void item_item::clear_has_unk_30() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void item_item::clear_unk_30() {
  unk_30_ = 0;
  clear_has_unk_30();
}
inline ::google::protobuf::int32 item_item::unk_30() const {
  return unk_30_;
}
inline void item_item::set_unk_30(::google::protobuf::int32 value) {
  set_has_unk_30();
  unk_30_ = value;
}

// optional int32 unk_31 = 31;
inline bool item_item::has_unk_31() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void item_item::set_has_unk_31() {
  _has_bits_[0] |= 0x20000000u;
}
inline void item_item::clear_has_unk_31() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void item_item::clear_unk_31() {
  unk_31_ = 0;
  clear_has_unk_31();
}
inline ::google::protobuf::int32 item_item::unk_31() const {
  return unk_31_;
}
inline void item_item::set_unk_31(::google::protobuf::int32 value) {
  set_has_unk_31();
  unk_31_ = value;
}

// optional int32 unk_32 = 32;
inline bool item_item::has_unk_32() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void item_item::set_has_unk_32() {
  _has_bits_[0] |= 0x40000000u;
}
inline void item_item::clear_has_unk_32() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void item_item::clear_unk_32() {
  unk_32_ = 0;
  clear_has_unk_32();
}
inline ::google::protobuf::int32 item_item::unk_32() const {
  return unk_32_;
}
inline void item_item::set_unk_32(::google::protobuf::int32 value) {
  set_has_unk_32();
  unk_32_ = value;
}

// optional int32 unk_33 = 33;
inline bool item_item::has_unk_33() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void item_item::set_has_unk_33() {
  _has_bits_[0] |= 0x80000000u;
}
inline void item_item::clear_has_unk_33() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void item_item::clear_unk_33() {
  unk_33_ = 0;
  clear_has_unk_33();
}
inline ::google::protobuf::int32 item_item::unk_33() const {
  return unk_33_;
}
inline void item_item::set_unk_33(::google::protobuf::int32 value) {
  set_has_unk_33();
  unk_33_ = value;
}

// optional int32 unk_34 = 34;
inline bool item_item::has_unk_34() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void item_item::set_has_unk_34() {
  _has_bits_[1] |= 0x00000001u;
}
inline void item_item::clear_has_unk_34() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void item_item::clear_unk_34() {
  unk_34_ = 0;
  clear_has_unk_34();
}
inline ::google::protobuf::int32 item_item::unk_34() const {
  return unk_34_;
}
inline void item_item::set_unk_34(::google::protobuf::int32 value) {
  set_has_unk_34();
  unk_34_ = value;
}

// optional int32 unk_35 = 35;
inline bool item_item::has_unk_35() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void item_item::set_has_unk_35() {
  _has_bits_[1] |= 0x00000002u;
}
inline void item_item::clear_has_unk_35() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void item_item::clear_unk_35() {
  unk_35_ = 0;
  clear_has_unk_35();
}
inline ::google::protobuf::int32 item_item::unk_35() const {
  return unk_35_;
}
inline void item_item::set_unk_35(::google::protobuf::int32 value) {
  set_has_unk_35();
  unk_35_ = value;
}

// optional int32 unk_36 = 36;
inline bool item_item::has_unk_36() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void item_item::set_has_unk_36() {
  _has_bits_[1] |= 0x00000004u;
}
inline void item_item::clear_has_unk_36() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void item_item::clear_unk_36() {
  unk_36_ = 0;
  clear_has_unk_36();
}
inline ::google::protobuf::int32 item_item::unk_36() const {
  return unk_36_;
}
inline void item_item::set_unk_36(::google::protobuf::int32 value) {
  set_has_unk_36();
  unk_36_ = value;
}

// optional int32 unk_37 = 37;
inline bool item_item::has_unk_37() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void item_item::set_has_unk_37() {
  _has_bits_[1] |= 0x00000008u;
}
inline void item_item::clear_has_unk_37() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void item_item::clear_unk_37() {
  unk_37_ = 0;
  clear_has_unk_37();
}
inline ::google::protobuf::int32 item_item::unk_37() const {
  return unk_37_;
}
inline void item_item::set_unk_37(::google::protobuf::int32 value) {
  set_has_unk_37();
  unk_37_ = value;
}

// optional string scene = 38;
inline bool item_item::has_scene() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void item_item::set_has_scene() {
  _has_bits_[1] |= 0x00000010u;
}
inline void item_item::clear_has_scene() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void item_item::clear_scene() {
  if (scene_ != &::google::protobuf::internal::kEmptyString) {
    scene_->clear();
  }
  clear_has_scene();
}
inline const ::std::string& item_item::scene() const {
  return *scene_;
}
inline void item_item::set_scene(const ::std::string& value) {
  set_has_scene();
  if (scene_ == &::google::protobuf::internal::kEmptyString) {
    scene_ = new ::std::string;
  }
  scene_->assign(value);
}
inline void item_item::set_scene(const char* value) {
  set_has_scene();
  if (scene_ == &::google::protobuf::internal::kEmptyString) {
    scene_ = new ::std::string;
  }
  scene_->assign(value);
}
inline void item_item::set_scene(const char* value, size_t size) {
  set_has_scene();
  if (scene_ == &::google::protobuf::internal::kEmptyString) {
    scene_ = new ::std::string;
  }
  scene_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* item_item::mutable_scene() {
  set_has_scene();
  if (scene_ == &::google::protobuf::internal::kEmptyString) {
    scene_ = new ::std::string;
  }
  return scene_;
}
inline ::std::string* item_item::release_scene() {
  clear_has_scene();
  if (scene_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scene_;
    scene_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 unk_39 = 39;
inline bool item_item::has_unk_39() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void item_item::set_has_unk_39() {
  _has_bits_[1] |= 0x00000020u;
}
inline void item_item::clear_has_unk_39() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void item_item::clear_unk_39() {
  unk_39_ = 0;
  clear_has_unk_39();
}
inline ::google::protobuf::int32 item_item::unk_39() const {
  return unk_39_;
}
inline void item_item::set_unk_39(::google::protobuf::int32 value) {
  set_has_unk_39();
  unk_39_ = value;
}

// optional string unk_40 = 40;
inline bool item_item::has_unk_40() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void item_item::set_has_unk_40() {
  _has_bits_[1] |= 0x00000040u;
}
inline void item_item::clear_has_unk_40() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void item_item::clear_unk_40() {
  if (unk_40_ != &::google::protobuf::internal::kEmptyString) {
    unk_40_->clear();
  }
  clear_has_unk_40();
}
inline const ::std::string& item_item::unk_40() const {
  return *unk_40_;
}
inline void item_item::set_unk_40(const ::std::string& value) {
  set_has_unk_40();
  if (unk_40_ == &::google::protobuf::internal::kEmptyString) {
    unk_40_ = new ::std::string;
  }
  unk_40_->assign(value);
}
inline void item_item::set_unk_40(const char* value) {
  set_has_unk_40();
  if (unk_40_ == &::google::protobuf::internal::kEmptyString) {
    unk_40_ = new ::std::string;
  }
  unk_40_->assign(value);
}
inline void item_item::set_unk_40(const char* value, size_t size) {
  set_has_unk_40();
  if (unk_40_ == &::google::protobuf::internal::kEmptyString) {
    unk_40_ = new ::std::string;
  }
  unk_40_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* item_item::mutable_unk_40() {
  set_has_unk_40();
  if (unk_40_ == &::google::protobuf::internal::kEmptyString) {
    unk_40_ = new ::std::string;
  }
  return unk_40_;
}
inline ::std::string* item_item::release_unk_40() {
  clear_has_unk_40();
  if (unk_40_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unk_40_;
    unk_40_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 unk_41 = 41;
inline bool item_item::has_unk_41() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void item_item::set_has_unk_41() {
  _has_bits_[1] |= 0x00000080u;
}
inline void item_item::clear_has_unk_41() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void item_item::clear_unk_41() {
  unk_41_ = 0;
  clear_has_unk_41();
}
inline ::google::protobuf::int32 item_item::unk_41() const {
  return unk_41_;
}
inline void item_item::set_unk_41(::google::protobuf::int32 value) {
  set_has_unk_41();
  unk_41_ = value;
}

// optional string ff = 42;
inline bool item_item::has_ff() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void item_item::set_has_ff() {
  _has_bits_[1] |= 0x00000100u;
}
inline void item_item::clear_has_ff() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void item_item::clear_ff() {
  if (ff_ != &::google::protobuf::internal::kEmptyString) {
    ff_->clear();
  }
  clear_has_ff();
}
inline const ::std::string& item_item::ff() const {
  return *ff_;
}
inline void item_item::set_ff(const ::std::string& value) {
  set_has_ff();
  if (ff_ == &::google::protobuf::internal::kEmptyString) {
    ff_ = new ::std::string;
  }
  ff_->assign(value);
}
inline void item_item::set_ff(const char* value) {
  set_has_ff();
  if (ff_ == &::google::protobuf::internal::kEmptyString) {
    ff_ = new ::std::string;
  }
  ff_->assign(value);
}
inline void item_item::set_ff(const char* value, size_t size) {
  set_has_ff();
  if (ff_ == &::google::protobuf::internal::kEmptyString) {
    ff_ = new ::std::string;
  }
  ff_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* item_item::mutable_ff() {
  set_has_ff();
  if (ff_ == &::google::protobuf::internal::kEmptyString) {
    ff_ = new ::std::string;
  }
  return ff_;
}
inline ::std::string* item_item::release_ff() {
  clear_has_ff();
  if (ff_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ff_;
    ff_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 unk_43 = 43;
inline bool item_item::has_unk_43() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void item_item::set_has_unk_43() {
  _has_bits_[1] |= 0x00000200u;
}
inline void item_item::clear_has_unk_43() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void item_item::clear_unk_43() {
  unk_43_ = 0;
  clear_has_unk_43();
}
inline ::google::protobuf::int32 item_item::unk_43() const {
  return unk_43_;
}
inline void item_item::set_unk_43(::google::protobuf::int32 value) {
  set_has_unk_43();
  unk_43_ = value;
}

// optional int32 unk_44 = 44;
inline bool item_item::has_unk_44() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void item_item::set_has_unk_44() {
  _has_bits_[1] |= 0x00000400u;
}
inline void item_item::clear_has_unk_44() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void item_item::clear_unk_44() {
  unk_44_ = 0;
  clear_has_unk_44();
}
inline ::google::protobuf::int32 item_item::unk_44() const {
  return unk_44_;
}
inline void item_item::set_unk_44(::google::protobuf::int32 value) {
  set_has_unk_44();
  unk_44_ = value;
}

// -------------------------------------------------------------------

// item_item_c

// repeated .item_item items = 1;
inline int item_item_c::items_size() const {
  return items_.size();
}
inline void item_item_c::clear_items() {
  items_.Clear();
}
inline const ::item_item& item_item_c::items(int index) const {
  return items_.Get(index);
}
inline ::item_item* item_item_c::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::item_item* item_item_c::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::item_item >&
item_item_c::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::item_item >*
item_item_c::mutable_items() {
  return &items_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_item_5fitem_5fc_2eproto__INCLUDED
